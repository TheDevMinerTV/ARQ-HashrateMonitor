

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      ArQmA Javascript RPC Library - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link id="google-font" href="https://fonts.googleapis.com/css?family=Roboto+Mono|Cutive+Mono|Roboto:300,400,700" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="styles/highlight-themes/current.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/collapsible.css">
  <link type="text/css" rel="stylesheet" href="styles/style-switcher.css">
  <link type="text/css" rel="stylesheet" href="styles/selectric.css">
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <script src="https://embed.runkit.com"></script>
  <style id="style-switcher-styles">
    nav {
        background: #282c34;
    }
    .hljs {
        background: #1d2027;
    }
    .nav-container > ul > li.active a {
        color: #BAB87E;
    }
    .nav-container > ul > li.active a:hover {
        color: #8F8D61;
    }
    .nav-container > ul > li.active ul {
        border-color: #8F8D61;
    }
    h4.name {
        color: #8F8D61;
    }
    .params > div > code, .params > div > em {
        color: #8F8D61;
    }
    a, a:active {
        color: #8F8D61;
    }
    .hljs-doctag, .hljs-keyword, .hljs-formula {
        color: #8F8D61;
    }
    nav ul a:hover, nav ul a:active {
        color: #8F8D61;
    }
  </style>
</head>

<body>
  <header class="header-fixed">
      <h1>
        <a href="index.html" title="modernTemplate.title">
            
            ArQmA RPC JS
        </a>
      </h1>
      <div class="center-header">
          <ul>
            
          </ul>
      </div>
      <div class="right-header">
           
                <a href="https://github.com/arqma/arqma-rpc-js" title="View it on Github" style="">
                    <i class="fab fa-github-alt"></i>
                </a>
           
                <a href="https://www.npmjs.com/package/@arqma/arqma-rpc" title="View it on NPM" style="font-size: 19px">
                    <i class="fas fa-exclamation-triangle"></i>
                </a>
           
      </div>
  </header>

  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <nav>
    <div id="menu-container" class="scrollbar-inner">
        <div class="nav-container">
            <h3>Classes</h3><ul><li id="RPCDaemon-nav"><a href="RPCDaemon.html">RPCDaemon</a><ul class='methods'><li data-type="method" id="RPCDaemon-flushTxPool-nav"><a href="RPCDaemon.html#flushTxPool">flushTxPool</a></li><li data-type="method" id="RPCDaemon-getAlternateChains-nav"><a href="RPCDaemon.html#getAlternateChains">getAlternateChains</a></li><li data-type="method" id="RPCDaemon-getBans-nav"><a href="RPCDaemon.html#getBans">getBans</a></li><li data-type="method" id="RPCDaemon-getBlock-nav"><a href="RPCDaemon.html#getBlock">getBlock</a></li><li data-type="method" id="RPCDaemon-getBlockCount-nav"><a href="RPCDaemon.html#getBlockCount">getBlockCount</a></li><li data-type="method" id="RPCDaemon-getBlockHash-nav"><a href="RPCDaemon.html#getBlockHash">getBlockHash</a></li><li data-type="method" id="RPCDaemon-getBlockHeaderByHash-nav"><a href="RPCDaemon.html#getBlockHeaderByHash">getBlockHeaderByHash</a></li><li data-type="method" id="RPCDaemon-getBlockHeaderByHeight-nav"><a href="RPCDaemon.html#getBlockHeaderByHeight">getBlockHeaderByHeight</a></li><li data-type="method" id="RPCDaemon-getBlockHeaderByHeight-nav"><a href="RPCDaemon.html#getBlockHeaderByHeight">getBlockHeaderByHeight</a></li><li data-type="method" id="RPCDaemon-getBlockTemplate-nav"><a href="RPCDaemon.html#getBlockTemplate">getBlockTemplate</a></li><li data-type="method" id="RPCDaemon-getCoinbaseTxSum-nav"><a href="RPCDaemon.html#getCoinbaseTxSum">getCoinbaseTxSum</a></li><li data-type="method" id="RPCDaemon-getConnections-nav"><a href="RPCDaemon.html#getConnections">getConnections</a></li><li data-type="method" id="RPCDaemon-getFeeEstimate-nav"><a href="RPCDaemon.html#getFeeEstimate">getFeeEstimate</a></li><li data-type="method" id="RPCDaemon-getHardForkInfo-nav"><a href="RPCDaemon.html#getHardForkInfo">getHardForkInfo</a></li><li data-type="method" id="RPCDaemon-getInfo-nav"><a href="RPCDaemon.html#getInfo">getInfo</a></li><li data-type="method" id="RPCDaemon-getLastBlockHeader-nav"><a href="RPCDaemon.html#getLastBlockHeader">getLastBlockHeader</a></li><li data-type="method" id="RPCDaemon-getOutputDistribution-nav"><a href="RPCDaemon.html#getOutputDistribution">getOutputDistribution</a></li><li data-type="method" id="RPCDaemon-getOutputHistogram-nav"><a href="RPCDaemon.html#getOutputHistogram">getOutputHistogram</a></li><li data-type="method" id="RPCDaemon-getTxPoolBacklog-nav"><a href="RPCDaemon.html#getTxPoolBacklog">getTxPoolBacklog</a></li><li data-type="method" id="RPCDaemon-getVersion-nav"><a href="RPCDaemon.html#getVersion">getVersion</a></li><li data-type="method" id="RPCDaemon-otherGetAltBlocksHashes-nav"><a href="RPCDaemon.html#otherGetAltBlocksHashes">otherGetAltBlocksHashes</a></li><li data-type="method" id="RPCDaemon-otherGetHeight-nav"><a href="RPCDaemon.html#otherGetHeight">otherGetHeight</a></li><li data-type="method" id="RPCDaemon-otherGetLimit-nav"><a href="RPCDaemon.html#otherGetLimit">otherGetLimit</a></li><li data-type="method" id="RPCDaemon-otherGetPeerList-nav"><a href="RPCDaemon.html#otherGetPeerList">otherGetPeerList</a></li><li data-type="method" id="RPCDaemon-otherGetTransactionPool-nav"><a href="RPCDaemon.html#otherGetTransactionPool">otherGetTransactionPool</a></li><li data-type="method" id="RPCDaemon-otherGetTransactionPool-nav"><a href="RPCDaemon.html#otherGetTransactionPool">otherGetTransactionPool</a></li><li data-type="method" id="RPCDaemon-otherGetTransactions-nav"><a href="RPCDaemon.html#otherGetTransactions">otherGetTransactions</a></li><li data-type="method" id="RPCDaemon-otherIsKeyImageSpent-nav"><a href="RPCDaemon.html#otherIsKeyImageSpent">otherIsKeyImageSpent</a></li><li data-type="method" id="RPCDaemon-otherOutPeers-nav"><a href="RPCDaemon.html#otherOutPeers">otherOutPeers</a></li><li data-type="method" id="RPCDaemon-otherOutPeers-nav"><a href="RPCDaemon.html#otherOutPeers">otherOutPeers</a></li><li data-type="method" id="RPCDaemon-otherSaveBc-nav"><a href="RPCDaemon.html#otherSaveBc">otherSaveBc</a></li><li data-type="method" id="RPCDaemon-otherSendRawTransaction-nav"><a href="RPCDaemon.html#otherSendRawTransaction">otherSendRawTransaction</a></li><li data-type="method" id="RPCDaemon-otherSetLimit-nav"><a href="RPCDaemon.html#otherSetLimit">otherSetLimit</a></li><li data-type="method" id="RPCDaemon-otherSetLogCategories-nav"><a href="RPCDaemon.html#otherSetLogCategories">otherSetLogCategories</a></li><li data-type="method" id="RPCDaemon-otherSetLogHashrate-nav"><a href="RPCDaemon.html#otherSetLogHashrate">otherSetLogHashrate</a></li><li data-type="method" id="RPCDaemon-otherSetLogLevel-nav"><a href="RPCDaemon.html#otherSetLogLevel">otherSetLogLevel</a></li><li data-type="method" id="RPCDaemon-otherStartMining-nav"><a href="RPCDaemon.html#otherStartMining">otherStartMining</a></li><li data-type="method" id="RPCDaemon-otherStopDaemon-nav"><a href="RPCDaemon.html#otherStopDaemon">otherStopDaemon</a></li><li data-type="method" id="RPCDaemon-otherStopMining-nav"><a href="RPCDaemon.html#otherStopMining">otherStopMining</a></li><li data-type="method" id="RPCDaemon-otherStopMining-nav"><a href="RPCDaemon.html#otherStopMining">otherStopMining</a></li><li data-type="method" id="RPCDaemon-relayTx-nav"><a href="RPCDaemon.html#relayTx">relayTx</a></li><li data-type="method" id="RPCDaemon-setBans-nav"><a href="RPCDaemon.html#setBans">setBans</a></li><li data-type="method" id="RPCDaemon-submitBlock-nav"><a href="RPCDaemon.html#submitBlock">submitBlock</a></li><li data-type="method" id="RPCDaemon-syncInfo-nav"><a href="RPCDaemon.html#syncInfo">syncInfo</a></li></ul></li><li id="RPCWallet-nav"><a href="RPCWallet.html">RPCWallet</a><ul class='methods'><li data-type="method" id="RPCWallet-addAddressBook-nav"><a href="RPCWallet.html#addAddressBook">addAddressBook</a></li><li data-type="method" id="RPCWallet-autoRefresh-nav"><a href="RPCWallet.html#autoRefresh">autoRefresh</a></li><li data-type="method" id="RPCWallet-changeWalletPassword-nav"><a href="RPCWallet.html#changeWalletPassword">changeWalletPassword</a></li><li data-type="method" id="RPCWallet-checkReserveProof-nav"><a href="RPCWallet.html#checkReserveProof">checkReserveProof</a></li><li data-type="method" id="RPCWallet-checkSpendProof-nav"><a href="RPCWallet.html#checkSpendProof">checkSpendProof</a></li><li data-type="method" id="RPCWallet-checkTxKey-nav"><a href="RPCWallet.html#checkTxKey">checkTxKey</a></li><li data-type="method" id="RPCWallet-checkTxProof-nav"><a href="RPCWallet.html#checkTxProof">checkTxProof</a></li><li data-type="method" id="RPCWallet-closeWallet-nav"><a href="RPCWallet.html#closeWallet">closeWallet</a></li><li data-type="method" id="RPCWallet-createAccount-nav"><a href="RPCWallet.html#createAccount">createAccount</a></li><li data-type="method" id="RPCWallet-createAddress-nav"><a href="RPCWallet.html#createAddress">createAddress</a></li><li data-type="method" id="RPCWallet-createWallet-nav"><a href="RPCWallet.html#createWallet">createWallet</a></li><li data-type="method" id="RPCWallet-deleteAddressBook-nav"><a href="RPCWallet.html#deleteAddressBook">deleteAddressBook</a></li><li data-type="method" id="RPCWallet-exportKeyImages-nav"><a href="RPCWallet.html#exportKeyImages">exportKeyImages</a></li><li data-type="method" id="RPCWallet-exportMultisigInfo-nav"><a href="RPCWallet.html#exportMultisigInfo">exportMultisigInfo</a></li><li data-type="method" id="RPCWallet-exportOutputs-nav"><a href="RPCWallet.html#exportOutputs">exportOutputs</a></li><li data-type="method" id="RPCWallet-finalizeMultisig-nav"><a href="RPCWallet.html#finalizeMultisig">finalizeMultisig</a></li><li data-type="method" id="RPCWallet-generateFromKeys-nav"><a href="RPCWallet.html#generateFromKeys">generateFromKeys</a></li><li data-type="method" id="RPCWallet-getAccounts-nav"><a href="RPCWallet.html#getAccounts">getAccounts</a></li><li data-type="method" id="RPCWallet-getAccountTags-nav"><a href="RPCWallet.html#getAccountTags">getAccountTags</a></li><li data-type="method" id="RPCWallet-getAddress-nav"><a href="RPCWallet.html#getAddress">getAddress</a></li><li data-type="method" id="RPCWallet-getAddressBook-nav"><a href="RPCWallet.html#getAddressBook">getAddressBook</a></li><li data-type="method" id="RPCWallet-getAddressIndex-nav"><a href="RPCWallet.html#getAddressIndex">getAddressIndex</a></li><li data-type="method" id="RPCWallet-getAttribute-nav"><a href="RPCWallet.html#getAttribute">getAttribute</a></li><li data-type="method" id="RPCWallet-getBalance-nav"><a href="RPCWallet.html#getBalance">getBalance</a></li><li data-type="method" id="RPCWallet-getBulkPayments-nav"><a href="RPCWallet.html#getBulkPayments">getBulkPayments</a></li><li data-type="method" id="RPCWallet-getHeight-nav"><a href="RPCWallet.html#getHeight">getHeight</a></li><li data-type="method" id="RPCWallet-getLanguages-nav"><a href="RPCWallet.html#getLanguages">getLanguages</a></li><li data-type="method" id="RPCWallet-getPayments-nav"><a href="RPCWallet.html#getPayments">getPayments</a></li><li data-type="method" id="RPCWallet-getReserveProof-nav"><a href="RPCWallet.html#getReserveProof">getReserveProof</a></li><li data-type="method" id="RPCWallet-getSpendProof-nav"><a href="RPCWallet.html#getSpendProof">getSpendProof</a></li><li data-type="method" id="RPCWallet-getTransferByTxId-nav"><a href="RPCWallet.html#getTransferByTxId">getTransferByTxId</a></li><li data-type="method" id="RPCWallet-getTransfers-nav"><a href="RPCWallet.html#getTransfers">getTransfers</a></li><li data-type="method" id="RPCWallet-getTxKey-nav"><a href="RPCWallet.html#getTxKey">getTxKey</a></li><li data-type="method" id="RPCWallet-getTxNotes-nav"><a href="RPCWallet.html#getTxNotes">getTxNotes</a></li><li data-type="method" id="RPCWallet-getTxProof-nav"><a href="RPCWallet.html#getTxProof">getTxProof</a></li><li data-type="method" id="RPCWallet-getVersion-nav"><a href="RPCWallet.html#getVersion">getVersion</a></li><li data-type="method" id="RPCWallet-importKeyImages-nav"><a href="RPCWallet.html#importKeyImages">importKeyImages</a></li><li data-type="method" id="RPCWallet-importMultisigInfo-nav"><a href="RPCWallet.html#importMultisigInfo">importMultisigInfo</a></li><li data-type="method" id="RPCWallet-importOutputs-nav"><a href="RPCWallet.html#importOutputs">importOutputs</a></li><li data-type="method" id="RPCWallet-incomingTransfers-nav"><a href="RPCWallet.html#incomingTransfers">incomingTransfers</a></li><li data-type="method" id="RPCWallet-isMultisig-nav"><a href="RPCWallet.html#isMultisig">isMultisig</a></li><li data-type="method" id="RPCWallet-labelAccount-nav"><a href="RPCWallet.html#labelAccount">labelAccount</a></li><li data-type="method" id="RPCWallet-labelAddress-nav"><a href="RPCWallet.html#labelAddress">labelAddress</a></li><li data-type="method" id="RPCWallet-makeIntegratedAddress-nav"><a href="RPCWallet.html#makeIntegratedAddress">makeIntegratedAddress</a></li><li data-type="method" id="RPCWallet-makeMultisig-nav"><a href="RPCWallet.html#makeMultisig">makeMultisig</a></li><li data-type="method" id="RPCWallet-makeUri-nav"><a href="RPCWallet.html#makeUri">makeUri</a></li><li data-type="method" id="RPCWallet-openWallet-nav"><a href="RPCWallet.html#openWallet">openWallet</a></li><li data-type="method" id="RPCWallet-parseUri-nav"><a href="RPCWallet.html#parseUri">parseUri</a></li><li data-type="method" id="RPCWallet-prepareMultisig-nav"><a href="RPCWallet.html#prepareMultisig">prepareMultisig</a></li><li data-type="method" id="RPCWallet-queryKey-nav"><a href="RPCWallet.html#queryKey">queryKey</a></li><li data-type="method" id="RPCWallet-refresh-nav"><a href="RPCWallet.html#refresh">refresh</a></li><li data-type="method" id="RPCWallet-relayTx-nav"><a href="RPCWallet.html#relayTx">relayTx</a></li><li data-type="method" id="RPCWallet-rescanBlockchain-nav"><a href="RPCWallet.html#rescanBlockchain">rescanBlockchain</a></li><li data-type="method" id="RPCWallet-rescanSpent-nav"><a href="RPCWallet.html#rescanSpent">rescanSpent</a></li><li data-type="method" id="RPCWallet-restoreDeterministicWallet-nav"><a href="RPCWallet.html#restoreDeterministicWallet">restoreDeterministicWallet</a></li><li data-type="method" id="RPCWallet-setAccountTagDescription-nav"><a href="RPCWallet.html#setAccountTagDescription">setAccountTagDescription</a></li><li data-type="method" id="RPCWallet-setAttribute-nav"><a href="RPCWallet.html#setAttribute">setAttribute</a></li><li data-type="method" id="RPCWallet-setDaemon-nav"><a href="RPCWallet.html#setDaemon">setDaemon</a></li><li data-type="method" id="RPCWallet-setLogCategories-nav"><a href="RPCWallet.html#setLogCategories">setLogCategories</a></li><li data-type="method" id="RPCWallet-setLogLevel-nav"><a href="RPCWallet.html#setLogLevel">setLogLevel</a></li><li data-type="method" id="RPCWallet-setTxNotes-nav"><a href="RPCWallet.html#setTxNotes">setTxNotes</a></li><li data-type="method" id="RPCWallet-sign-nav"><a href="RPCWallet.html#sign">sign</a></li><li data-type="method" id="RPCWallet-signMultisig-nav"><a href="RPCWallet.html#signMultisig">signMultisig</a></li><li data-type="method" id="RPCWallet-signTransfer-nav"><a href="RPCWallet.html#signTransfer">signTransfer</a></li><li data-type="method" id="RPCWallet-splitIntegratedAddress-nav"><a href="RPCWallet.html#splitIntegratedAddress">splitIntegratedAddress</a></li><li data-type="method" id="RPCWallet-startMining-nav"><a href="RPCWallet.html#startMining">startMining</a></li><li data-type="method" id="RPCWallet-stopMining-nav"><a href="RPCWallet.html#stopMining">stopMining</a></li><li data-type="method" id="RPCWallet-stopWallet-nav"><a href="RPCWallet.html#stopWallet">stopWallet</a></li><li data-type="method" id="RPCWallet-store-nav"><a href="RPCWallet.html#store">store</a></li><li data-type="method" id="RPCWallet-submitMultisig-nav"><a href="RPCWallet.html#submitMultisig">submitMultisig</a></li><li data-type="method" id="RPCWallet-submitTransfer-nav"><a href="RPCWallet.html#submitTransfer">submitTransfer</a></li><li data-type="method" id="RPCWallet-sweepAll-nav"><a href="RPCWallet.html#sweepAll">sweepAll</a></li><li data-type="method" id="RPCWallet-sweepDust-nav"><a href="RPCWallet.html#sweepDust">sweepDust</a></li><li data-type="method" id="RPCWallet-sweepSingle-nav"><a href="RPCWallet.html#sweepSingle">sweepSingle</a></li><li data-type="method" id="RPCWallet-tagAccounts-nav"><a href="RPCWallet.html#tagAccounts">tagAccounts</a></li><li data-type="method" id="RPCWallet-transfer-nav"><a href="RPCWallet.html#transfer">transfer</a></li><li data-type="method" id="RPCWallet-transferSplit-nav"><a href="RPCWallet.html#transferSplit">transferSplit</a></li><li data-type="method" id="RPCWallet-untagAccounts-nav"><a href="RPCWallet.html#untagAccounts">untagAccounts</a></li><li data-type="method" id="RPCWallet-validateAddress-nav"><a href="RPCWallet.html#validateAddress">validateAddress</a></li><li data-type="method" id="RPCWallet-verify-nav"><a href="RPCWallet.html#verify">verify</a></li></ul></li></ul>
        </div>
    </div>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        rpcDaemon.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>'use strict'

const RPCClient = require('../lib/rpcClient.js')

var RPCDaemon = (function () {
  /**
  * Initializes a new instance of RPCDaemon.&lt;br>
  * When no username is provided digest authentication will not be used.
  * @constructs RPCDaemon
  * @param {Object} opts
  * @param {string} opts.url - complete url with port 'http://127.0.0.1:19994' or 'https://127.0.0.1:19994'.
  * @param {string} [opts.username='Mufasa'] - username.
  * @param {string} [opts.password='Circle of Life'] - password.
  * @return {RPCDaemon} returns a new instance of RPCDaemon.
  */
  RPCDaemon.prototype = Object.create(RPCClient.prototype)
  RPCDaemon.prototype.constructor = RPCDaemon

  // remove requestLimited as we queue the top functions
  delete RPCDaemon.prototype.requestLimited

  function RPCDaemon (opts) {
    RPCClient.call(this, opts)
  }

  RPCDaemon.prototype.getBlockCount = function () {
    /**
    * Look up how many blocks are in the longest chain known to the node.
    * @function
    * @name RPCDaemon#getBlockCount
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  count: 144188,
    *  status: 'OK'
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('getblockcount')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlockHash = function (opts) {
    /**
    * Look up a block's hash by its height.
    * @function
    * @name RPCDaemon#getBlockHash
    * @param {Object} opts
    * @param {number[]} opts.height - block height (only one unsigned integer).
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * 6115a8e9902af15d31d14c698621d54e9bb594b0da053591ec5d1ceb537960ea
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.height === 'undefined') return reject(new Error('must specify height'))
        return this._request_rpc('on_get_block_hash', opts.height)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlockTemplate = function (opts) {
    /**
    * Get a block template on which mining a new block.
    * @function
    * @name RPCDaemon#getBlockTemplate
    * @param {Object} opts
    * @param {string} opts.wallet_address - Address of wallet to receive coinbase transactions if block is successfully mined.
    * @param {number} opts.reserve_size - Reserve size.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  blockhashing_blob: '0b0bdc83ffe405686cd8e06fea333582a7d521c6899a00266f107e9212ebe7b7626258893c9a
    *                     9000000000cc172232b1465580877b898f8f6021ad264705fb44d4ce4116576c951865dc6e02',
    *  blocktemplate_blob: '0b0bdc83ffe405686cd8e06fea333582a7d521c6899a00266f107e9212ebe7b7626258893c9a
    *                      900000000002b3e70801ffa1e70801919ef5bc46027fecb474827691e150863765eeb11c7fda
    *                      e88e9cf413468b3f46a6fd1416174f2101958d80e5dd64b962d539a18e2fab89cd6abf1ddd2d
    *                      f4b6c2b890c1fad31acd310001eae8de4b74bf117c059ba9b68c9e81a2465997319dd5805a90
    *                      dfae8290b33ab9',
    *  difficulty: 58700182,
    *  expected_reward: 18918231825,
    *  height: 144289,
    *  prev_hash: '686cd8e06fea333582a7d521c6899a00266f107e9212ebe7b7626258893c9a90',
    *  reserved_offset: 127,
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.wallet_address === 'undefined') return reject(new Error('must specify wallet_address'))
        if (typeof opts.reserve_size === 'undefined') return reject(new Error('must specify reserve_size'))
        return this._request_rpc('getblocktemplate', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.submitBlock = function (opts) {
    /**
    * Look up a block's hash by its height.
    * @function
    * @name RPCDaemon#submitBlock
    * @param {Object} opts
    * @param {string[]} opts.blob -  list of block blobs which have been mined.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output with error message when the block is not accepted. You need to catch it with promise.&lt;/b>&lt;/caption>
    * { Error: Block not accepted
    *   at _request.then (C:\myDev\arqma-rpc-js\src\rpcDaemon.js:761:25)
    *   at process._tickCallback (internal/process/next_tick.js:68:7) code: -7 }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.blob === 'undefined') return reject(new Error('must specify blob'))
        if (!(opts.blob instanceof Array) || Object.prototype.toString.call(opts.blob) !== '[object Array]') return reject(new Error('blob should be an array of strings'))
        return this._request_rpc('submit_block', opts.blob)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getLastBlockHeader = function () {
    /**
    * Block header information for the most recent block is easily retrieved with this method.
    * @function
    * @name RPCDaemon#getLastBlockHeader
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  block_header:
    *  {
    *    block_size: 147,
    *    cumulative_difficulty: 20379479802883,
    *    depth: 0,
    *    difficulty: 61400097,
    *    hash: 'c99c2f9a53e4bab5d08f9820ee555d62059e0e9bf799fbe07a6137aac607f4e8',
    *    height: 145009,
    *    major_version: 11,
    *    minor_version: 11,
    *    nonce: 3441194797,
    *    num_txes: 0,
    *    orphan_status: false,
    *    pow_hash: '',
    *    prev_hash: '53d6437ac32fc49e0ee8b24f63046c6e1e6e0491f6d1b6797b025b66ad1b4a40',
    *    reward: 18911700042,
    *    timestamp: 1554058920 },
    *    status: 'OK',
    *    untrusted: false
    *  }
    *  count: 144188,
    *  status: 'OK'
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_last_block_header')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlockHeaderByHash = function (opts) {
    /**
    * Block header information can be retrieved using hash.
    * @function
    * @name RPCDaemon#getBlockHeaderByHash
    * @param {Object} opts
    * @param {string} opts.hash - The block's sha256 hash.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  block_header:
    *  {
    *   block_size: 147,
    *   cumulative_difficulty: 16146009479722,
    *   depth: 30823,
    *   difficulty: 109000131,
    *   hash: '5859dbfca776cc006f6bfd00a41363f8ffcc20e6f217c484df0b47ae8cc2458a',
    *   height: 114196,
    *   major_version: 10,
    *   minor_version: 10,
    *   nonce: 2147508795,
    *   num_txes: 0,
    *   orphan_status: false,
    *   pow_hash: '',
    *   prev_hash: 'be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf24e74',
    *   reward: 19191616421,
    *   timestamp: 1550322226
    *  },
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.hash === 'undefined') return reject(new Error('must specify hash'))
        return this._request_rpc('get_block_header_by_hash', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlockHeaderByHeight = function (opts) {
    /**
    * Block header information can be retrieved using height.
    * @function
    * @name RPCDaemon#getBlockHeaderByHeight
    * @param {Object} opts
    * @param {number} opts.height - The block's height.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  block_header:
    *  {
    *   block_size: 147,
    *   cumulative_difficulty: 16146009479722,
    *   depth: 30823,
    *   difficulty: 109000131,
    *   hash: '5859dbfca776cc006f6bfd00a41363f8ffcc20e6f217c484df0b47ae8cc2458a',
    *   height: 114196,
    *   major_version: 10,
    *   minor_version: 10,
    *   nonce: 2147508795,
    *   num_txes: 0,
    *   orphan_status: false,
    *   pow_hash: '',
    *   prev_hash: 'be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf24e74',
    *   reward: 19191616421,
    *   timestamp: 1550322226
    *  },
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.height === 'undefined') return reject(new Error('must specify height'))
        return this._request_rpc('get_block_header_by_height', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlockHeadersRange = function (opts) {
    /**
    * Similar to get_block_header_by_height above, but for a range of blocks.
    * This method includes a starting block height and an ending block height as parameters.
    * @function
    * @name RPCDaemon#getBlockHeaderByHeight
    * @param {Object} opts
    * @param {number} opts.start_height - The starting block's height.
    * @param {number} opts.end_height - The ending block's height.
    * @returns {Promise} Promise object
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  headers:
    *  [
    *   {
    *    block_size: 147,
    *    cumulative_difficulty: 16146009479722,
    *    depth: 30831,
    *    difficulty: 109000131,
    *    hash: '5859dbfca776cc006f6bfd00a41363f8ffcc20e6f217c484df0b47ae8cc2458a',
    *    height: 114196,
    *    major_version: 10,
    *    minor_version: 10,
    *    nonce: 2147508795,
    *    num_txes: 0,
    *    orphan_status: false,
    *    pow_hash: '',
    *    prev_hash: 'be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf24e74',
    *    reward: 19191616421,
    *    timestamp: 1550322226
    *   },
    *   {
    *    block_size: 147,
    *    cumulative_difficulty: 16146120479856,
    *    depth: 30830,
    *    difficulty: 111000134,
    *    hash: 'c27c128325bb3f47d76816789995d376268ee25f3cdcfb714580e34fe5cc8e08',
    *    height: 114197,
    *    major_version: 10,
    *    minor_version: 10,
    *    nonce: 541065496,
    *    num_txes: 0,
    *    orphan_status: false,
    *    pow_hash: '',
    *    prev_hash: '5859dbfca776cc006f6bfd00a41363f8ffcc20e6f217c484df0b47ae8cc2458a',
    *    reward: 19191607270,
    *    timestamp: 1550322551
    *   }
    *  ],
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.start_height === 'undefined') return reject(new Error('must specify start_height'))
        if (typeof opts.end_height === 'undefined') return reject(new Error('must specify end_height'))
        return this._request_rpc('get_block_headers_range', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBlock = function (opts) {
    /**
    * Full block information can be retrieved by either block height or hash.
    * @function
    * @name RPCDaemon#getBlock
    * @param {Object} opts
    * @param {number} [opts.height] -  The block's height.
    * @param {string} [opts.hash] -  The block's hash.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  blob: '0a0ab294a0e305be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf24e
    *         743b62008002a6fc0601ff94fc0601a5a7a3bf4702f0f7be480164ced3d5d28c49dd9baeb5ab2bd3
    *         29910838afd3e26cd85ad49b3e6101311398a1783551ba88c64c00135d0439d982fc4d70f48e1dff
    *         cca8146454e84303210091abcad5e3b8bc208e5361ffeebbb68a35e102a5225f4865e3503cf7e76a
    *         ff92021b000000000000000000000000005602009e000000000000000000000000',
    *  block_header:
    *  {
    *   block_size: 147,
    *   cumulative_difficulty: 16146009479722,
    *   depth: 31535,
    *   difficulty: 109000131,
    *   hash: '5859dbfca776cc006f6bfd00a41363f8ffcc20e6f217c484df0b47ae8cc2458a',
    *   height: 114196,
    *   major_version: 10,
    *   minor_version: 10,
    *   nonce: 2147508795,
    *   num_txes: 0,
    *   orphan_status: false,
    *   pow_hash: '',
    *   prev_hash: 'be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf24e74',
    *   reward: 19191616421,
    *   timestamp: 1550322226
    *  },
    *  json: '{\n  "major_version": 10, \n  "minor_version": 10, \n  "timestamp": 15503222
    *  26, \n  "prev_id": "be9bcd157ff60f9b174217608a5b419c451afa1d9d76c49edf54ac829bf2
    *  4e74", \n  "nonce": 2147508795, \n  "miner_tx": {\n    "version": 2, \n    "unlo
    *  ck_time": 114214, \n    "vin": [ {\n        "gen": {\n          "height": 114196
    *  \n        }\n      }\n    ], \n    "vout": [ {\n        "amount": 19191616421, \
    *  n        "target": {\n          "key": "f0f7be480164ced3d5d28c49dd9baeb5ab2bd329
    *  910838afd3e26cd85ad49b3e"\n        }\n      }\n    ], \n    "extra": [ 1, 49, 19
    *  , 152, 161, 120, 53, 81, 186, 136, 198, 76, 0, 19, 93, 4, 57, 217, 130, 252, 77,
    *  112, 244, 142, 29, 255, 204, 168, 20, 100, 84, 232, 67, 3, 33, 0, 145, 171, 202
    *  , 213, 227, 184, 188, 32, 142, 83, 97, 255, 238, 187, 182, 138, 53, 225, 2, 165,
    *  34, 95, 72, 101, 227, 80, 60, 247, 231, 106, 255, 146, 2, 27, 0, 0, 0, 0, 0, 0,
    *  0, 0, 0, 0, 0, 0, 0, 86, 2, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ], \n
    *  "rct_signatures": {\n      "type": 0\n    }\n  }, \n  "tx_hashes": [ ]\n}',
    *  miner_tx_hash: '691e09ce198a2953c391a292ed79d7a239ec929740503400a0ab3e3ee8cfad84',
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if ((typeof opts.height === 'undefined') &amp;&amp; (typeof opts.hash === 'undefined')) return reject(new Error('must specify height or hash'))
        return this._request_rpc('get_block', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getConnections = function () {
    /**
    * Retrieve information about incoming and outgoing connections to your node.
    * @function
    * @name RPCDaemon#getConnections
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  connections:
    *  [
    *   {
    *    address: '192.154.226.212:19993',
    *    avg_download: 1,
    *    avg_upload: 0,
    *    connection_id: 'cb8f0270c5b740fa9eb7aa1aedddb5cb',
    *    current_download: 2,
    *    current_upload: 0,
    *    height: 145745,
    *    host: '192.154.226.212',
    *    incoming: false,
    *    ip: '192.154.226.212',
    *    live_time: 20,
    *    local_ip: false,
    *    localhost: false,
    *    peer_id: 'c7f323892fb18784',
    *    port: '19993',
    *    pruning_seed: 0,
    *    recv_count: 22852,
    *    recv_idle_time: 13,
    *    send_count: 568,
    *    send_idle_time: 13,
    *    state: 'normal',
    *    support_flags: 1
    *   }, ...
    *  ]
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_connections')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getInfo = function () {
    /**
    * Retrieve general information about the state of your node and the network.
    * @function
    * @name RPCDaemon#getInfo
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  alt_blocks_count: 0,
    *  block_size_limit: 600000,
    *  block_size_median: 147,
    *  bootstrap_daemon_address: '',
    *  cumulative_difficulty: 20431347989483,
    *  database_size: 0,
    *  difficulty: 75600102,
    *  free_space: 243485646848,
    *  grey_peerlist_size: 62,
    *  height: 145746,
    *  height_without_bootstrap: 145746,
    *  incoming_connections_count: 7,
    *  mainnet: true,
    *  nettype: 'mainnet',
    *  offline: false,
    *  outgoing_connections_count: 8,
    *  rpc_connections_count: 2,
    *  stagenet: false,
    *  start_time: 1554144733,
    *  status: 'OK',
    *  target: 120,
    *  target_height: 145732,
    *  testnet: false,
    *  top_block_hash: '9df96b39bb2ca8953cbf8f2fffc8f9896a74f430cbe29dc0ad356986ef93024c',
    *  tx_count: 179362,
    *  tx_pool_size: 10,
    *  untrusted: false,
    *  was_bootstrap_ever_used: false,
    *  white_peerlist_size: 38
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_info')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getHardForkInfo = function () {
    /**
    * Look up information regarding hard fork voting and readiness.
    * @function
    * @name RPCDaemon#getHardForkInfo
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  earliest_height: 131650,
    *  enabled: true,
    *  state: 2,
    *  status: 'OK',
    *  threshold: 0,
    *  untrusted: false,
    *  version: 11,
    *  votes: 10080,
    *  voting: 11,
    *  window: 10080
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('hard_fork_info')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.setBans = function (opts) {
    /**
    * Ban another node by IP.
    * @function
    * @name RPCDaemon#setBans
    * @param {Object} opts
    * @param {string} [opts.host] - Host to ban.
    * @param {number} [opts.ip] - IP address to ban, in Int format.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.bans === 'undefined') return reject(new Error('must specify bans'))
        return this._request_rpc('set_bans', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getBans = function () {
    /**
    * Get list of banned IPs.
    * @function
    * @name RPCDaemon#getBans
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  bans:
    *  [
    *   { host: '192.168.1.50', ip: 838969536, seconds: 30 },
    *   { host: '192.168.1.51', ip: 855746752, seconds: 30 }
    *  ],
    *  status: 'OK'
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_bans')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.flushTxPool = function (opts) {
    /**
    * Flush tx ids from transaction pool.
    * @function
    * @name RPCDaemon#flushTxPool
    * @param {Object} [opts]
    * @param {string[]} [opts.txids] - list of transactions IDs to flush from pool (all tx ids flushed if empty).
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        return this._request_rpc('flush_txpool', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getOutputHistogram = function (opts) {
    /**
    * Get a histogram of output amounts.
    * @function
    * @name RPCDaemon#getOutputHistogram
    * @param {Object} [opts]
    * @param {number[]} [opts.amounts] -  list of unsigned int.
    * @param {number} [opts.min_count] -  unsigned int.
    * @param {number} [opts.max_count] -  unsigned int.
    * @param {boolean} [unlocked] -  boolean.
    * @param {number} [recent_cutoff] -  unsigned int.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  histogram:
    *  [
    *   {
    *    amount: 10000000,
    *    recent_instances: 0,
    *    total_instances: 1481,
    *    unlocked_instances: 0
    *   }
    *  ],
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        return this._request_rpc('get_output_histogram', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getCoinbaseTxSum = function (opts) {
    /**
    * Get the coinbase amount and the fees ammount for n last blocks starting at particular height.
    * @function
    * @name RPCDaemon#getCoinbaseTxSum
    * @param {Object} opts
    * @param {number} opts.height -  unsigned int; Block height from which getting the amounts.
    * @param {number} opts.count -  unsigned int; number of blocks to include in the sum
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  emission_amount: 7502006245466748,
    *  fee_amount: 0,
    *  status: 'OK'
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.height === 'undefined') return reject(new Error('must specify height'))
        if (typeof opts.count === 'undefined') return reject(new Error('must specify count'))
        return this._request_rpc('get_coinbase_tx_sum', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getVersion = function () {
    /**
    * Give the node current version.
    * @function
    * @name RPCDaemon#getVersion
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK', untrusted: false, version: 131077 }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_version')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getFeeEstimate = function (opts) {
    /**
    * Gives an estimation on fees per kB.
    * @function
    * @name RPCDaemon#getFeeEstimate
    * @param {Object} opts
    * @param {number} [opts.grace_blocks] - unsigned int.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { fee: 7560, status: 'OK', untrusted: false }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        return this._request_rpc('get_fee_estimate', opts)
      }).then((res) => {
        resolve(res)
      })
        .catch((err) => {
          reject(err)
        })
    })
  }

  RPCDaemon.prototype.getAlternateChains = function () {
    /**
    * Display alternative chains seen by the node.
    * @function
    * @name RPCDaemon#getAlternateChains
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_alternate_chains')
      }).then((res) => {
        resolve(res)
      })
        .catch((err) => {
          reject(err)
        })
    })
  }

  RPCDaemon.prototype.relayTx = function (opts) {
    /**
    * Relay a list of transaction IDs.
    * @function
    * @name RPCDaemon#relayTx
    * @param {Object} opts
    * @param {string[]} opts.txids - list of transaction IDs to relay.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.txids === 'undefined') return reject(new Error('must specify txids'))
        if (!(opts.txids instanceof Array) || Object.prototype.toString.call(opts.txids) !== '[object Array]') return reject(new Error('txids should be an array of strings'))
        return this._request_rpc('relay_tx', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.syncInfo = function () {
    /**
    * Get synchronisation informations.
    * @function
    * @name RPCDaemon#syncInfo
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  height: 149027,
    *  next_needed_pruning_seed: 0,
    *  overview: '[]',
    *  peers:
    *  [
    *   { info: [Object] },
    *   { info: [Object] },
    *   ... ,
    *   { info: [Object] }
    *  ],
    *  status: 'OK',
    *  target_height: 149009
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('sync_info')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getTxPoolBacklog = function () {
    /**
    * Get all transaction pool backlog.
    * @function
    * @name RPCDaemon#getTxPoolBacklog
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK', untrusted: false }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_rpc('get_txpool_backlog')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.getOutputDistribution = function (opts) {
    /**
    * Get Ouput Distribution.
    * @function
    * @name RPCDaemon#getOutputDistribution
    * @param {Object} opts
    * @param {number[]} opts.amounts -  list of amounts to look for.
    * @param {boolean} [opts.cumulative] - (default is false) States if the result should be cumulative (true or false).
    * @param {number} [opts.from_height] - (default is 0) - unsigned int.
    * @param {number} [opts.to_height] - (default is 0) - unsigned int.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK', untrusted: false }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        // JSON does not like binary data from this query
        opts.binary = false
        if (typeof opts.amounts === 'undefined') return reject(new Error('must specify amounts'))
        if (!(opts.amounts instanceof Array) || Object.prototype.toString.call(opts.amounts) !== '[object Array]') return reject(new Error('amounts should be an array of numbers'))
        return this._request_rpc('get_output_distribution', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetHeight = function () {
    /**
    * Get the node's current height.
    * @function
    * @name RPCDaemon#otherGetHeight
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { height: 149045, status: 'OK', untrusted: false }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_height')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetTransactions = function (opts) {
    /**
    * Full block information can be retrieved by either block height or hash.
    * @function
    * @name RPCDaemon#otherGetTransactions
    * @param {Object} opts
    * @param {string[]} opts.tx_hashes -  List of transaction hashes to look up.
    * @param {boolean} [opts.decode_as_json] - (false by default). If set true, the returned transaction information will be decoded rather than binary.
    * @param {boolean} [opts.prune] - (false by default).
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  status: 'OK',
    *  txs:
    *  [
    *   {
    *    as_hex: '02000202 ... 0f',
    *    as_json: '',
    *    block_height: 140732,
    *    block_timestamp: 1553537372,
    *    double_spend_seen: false,
    *    in_pool: false,
    *    output_indices: [Array],
    *    prunable_as_hex: '',
    *    prunable_hash:
    *    '79f87397ef265f27b32a659e0f3f73496527e2cb97228ee4a82f31ec972bd65b',
    *    pruned_as_hex: '',
    *    tx_hash: 'a43c51e3a216bb702e6be2746c02a366c8e3a05b08b50da5ada8e9481418e350'
    *   }
    *  ],
    *  txs_as_hex: [ '02000202 ... 0f' ],
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.txs_hashes === 'undefined') return reject(new Error('must specify txs_hashes'))
        if (!(opts.txs_hashes instanceof Array) || Object.prototype.toString.call(opts.txs_hashes) !== '[object Array]') return reject(new Error('txs_hashes should be an array of strings'))
        return this._request_other('get_transactions', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetAltBlocksHashes = function () {
    /**
    * Get the known blocks hashes which are not on the main chain.
    * @function
    * @name RPCDaemon#otherGetAltBlocksHashes
    * @returns {Promise} Promise object.
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_alt_blocks_hashes')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherIsKeyImageSpent = function (opts) {
    /**
    * Check if outputs have been spent using the key image associated with the output.
    * @function
    * @name RPCDaemon#otherIsKeyImageSpent
    * @param {Object} opts
    * @param {string[]} opts.key_images -  list of block blobs which have been mined.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { spent_status: [ 1 ], status: 'OK', untrusted: false }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.key_images === 'undefined') return reject(new Error('must specify key_images'))
        if (!(opts.key_images instanceof Array) || Object.prototype.toString.call(opts.key_images) !== '[object Array]') return reject(new Error('key_images should be an array of strings'))
        return this._request_other('is_key_image_spent', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSendRawTransaction = function (opts) {
    /**
    * Broadcast a raw transaction to the network.
    * @function
    * @name RPCDaemon#otherSendRawTransaction
    * @param {Object} opts
    * @param {string} opts.tx_as_hex -  Full transaction information as hexidecimal string.
    * @param {boolean} [opts.do_not_relay] - (false by default). Stop relaying transaction to other nodes.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  double_spend: false,
    *  fee_too_low: false,
    *  invalid_input: false,
    *  invalid_output: false,
    *  low_mixin: false,
    *  not_rct: false,
    *  not_relayed: true,
    *  overspend: false,
    *  reason: 'Not relayed',
    *  status: 'OK',
    *  too_big: false,
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.tx_as_hex === 'undefined') return reject(new Error('must specify tx_as_hex'))
        return this._request_other('send_raw_transaction', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherStartMining = function (opts) {
    /**
    * Start mining on the daemon.
    * @function
    * @name RPCDaemon#otherStartMining
    * @param {Object} opts
    * @param {boolean} opts.do_background_mining - States if the mining should run in background (true) or foreground (false).
    * @param {boolean} opts.ignore_battery - States if batery state (on laptop) should be ignored (true) or not (false).
    * @param {string} opts.miner_address - Account address to mine to.
    * @param {number} opts.threads_count - Number of mining thread to run.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.do_background_mining === 'undefined') return reject(new Error('must specify do_background_mining'))
        if (typeof opts.ignore_battery === 'undefined') return reject(new Error('must specify ignore_battery'))
        if (typeof opts.miner_address === 'undefined') return reject(new Error('must specify miner_address'))
        if (typeof opts.threads_count === 'undefined') return reject(new Error('must specify threads_count'))
        return this._request_other('start_mining', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherStopMining = function () {
    /**
    * Stop mining on the daemon.
    * @function
    * @name RPCDaemon#otherStopMining
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('stop_mining')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherMiningStatus = function () {
    /**
    * Get the mining status of the daemon.
    * @function
    * @name RPCDaemon#otherStopMining
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  active: true,
    *  address: 'ar4bfzwH4726kamvTg2wRNLkw16MR6DbbZMyuShYgKs58SknoAF8q7PBQ1XXAsGgH9feTWKKmYZNjaWphc7Wce1u33iKe2cL9',
    *  is_background_mining_enabled: true,
    *  speed: 2,
    *  status: 'OK',
    *  threads_count: 1
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('mining_status')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSaveBc = function () {
    /**
    * Save the blockchain. The blockchain does not need saving and is always saved when modified, however it does a sync to flush the filesystem cache onto the disk for safety purposes against Operating System or Harware crashes.
    * @function
    * @name RPCDaemon#otherSaveBc
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('save_bc')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetPeerList = function () {
    /**
    * Get the known peers list.
    * @function
    * @name RPCDaemon#otherGetPeerList
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  gray_list:
    *  [
    *   { host: '135790251',
    *     id: 17703185689409910000,
    *     ip: 135790251,
    *     last_seen: 1551473999,
    *     port: 19993,
    *     pruning_seed: 0 }, ...
    *  ]
    *  status: 'OK',
    *  white_list:
    *  [
    *   { host: '35263064',
    *     id: 3764929947382960000,
    *     ip: 35263064,
    *     last_seen: 1554553579,
    *     port: 19993,
    *     pruning_seed: 0 }, ...
    *  ]
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_peer_list')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSetLogHashrate = function (opts) {
    /**
    * Set the log hash rate display mode.
    * @function
    * @name RPCDaemon#otherSetLogHashrate
    * @param {Object} opts
    * @param {boolean} opts.visible - States if hash rate logs should be visible (true) or hidden (false)
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output while mining&lt;/b>&lt;/caption>
    * { "status": "OK" }
    * @example &lt;caption>&lt;b>Output while NOT mining. You need to catch it with promise.&lt;/b>&lt;/caption>
    * Error: NOT MINING
    * at _request.then (C:\myDev\arqma-rpc-js\src\rpcDaemon.js:1418:27)
    * at process._tickCallback (internal/process/next_tick.js:68:7)
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.visible === 'undefined') return reject(new Error('must specify visible'))
        return this._request_other('set_log_hash_rate', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSetLogLevel = function (opts) {
    /**
    * Set the daemon log level. By default, log level is set to 0.
    * @function
    * @name RPCDaemon#otherSetLogLevel
    * @param {Object} opts
    * @param {number} opts.level - Daemon log level to set from 0 (less verbose) to 4 (most verbose).
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { "status": "OK" }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.level === 'undefined') return reject(new Error('must specify level'))
        return this._request_other('set_log_level', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSetLogCategories = function (opts) {
    /**
    * Set the daemon log categories.&lt;br>
    * Categories are represented as a comma separated list of &lt;Category\>:&lt;level\> (similarly to syslog standard &lt;Facility\>:&lt;Severity-level\>), where:
    * &lt;p>&lt;ul>
    * Category is one of the following:
    *   &lt;li>\* - All facilities&lt;/li>
    *   &lt;li>default&lt;/li>
    *   &lt;li>net&lt;/li>
    *   &lt;li>net.http&lt;/li>
    *   &lt;li>net.p2p&lt;/li>
    *   &lt;li>logging&lt;/li>
    *   &lt;li>net.throttle&lt;/li>
    *   &lt;li>blockchain.db&lt;/li>
    *   &lt;li>blockchain.db.lmdb&lt;/li>
    *   &lt;li>bcutil&lt;/li>
    *   &lt;li>checkpoints&lt;/li>
    *   &lt;li>net.dns&lt;/li>
    *   &lt;li>net.dl&lt;/li>
    *   &lt;li>i18n&lt;/li>
    *   &lt;li>perf&lt;/li>
    *   &lt;li>stacktrace&lt;/li>
    *   &lt;li>updates&lt;/li>
    *   &lt;li>account&lt;/li>
    *   &lt;li>cn&lt;/li>
    *   &lt;li>difficulty&lt;/li>
    *   &lt;li>hardfork&lt;/li>
    *   &lt;li>miner&lt;/li>
    *   &lt;li>blockchain&lt;/li>
    *   &lt;li>txpool&lt;/li>
    *   &lt;li>cn.block_queue&lt;/li>
    *   &lt;li>net.cn&lt;/li>
    *   &lt;li>daemon&lt;/li>
    *   &lt;li>debugtools.deserialize&lt;/li>
    *   &lt;li>debugtools.objectsizes&lt;/li>
    *   &lt;li>device.ledger&lt;/li>
    *   &lt;li>wallet.gen_multisig&lt;/li>
    *   &lt;li>multisig&lt;/li>
    *   &lt;li>bulletproofs&lt;/li>
    *   &lt;li>ringct&lt;/li>
    *   &lt;li>daemon.rpc&lt;/li>
    *   &lt;li>wallet.simplewallet&lt;/li>
    *   &lt;li>WalletAPI&lt;/li>
    *   &lt;li>wallet.ringdb&lt;/li>
    *   &lt;li>wallet.wallet2&lt;/li>
    *   &lt;li>wallet.rpc&lt;/li>
    *   &lt;li>tests.core
    *   &lt;/ul>
    * &lt;ul>
    * Level is one of the following:
    *   &lt;li>FATAL - higher level&lt;/li>
    *   &lt;li>ERROR&lt;/li>
    *   &lt;li>WARNING&lt;/li>
    *   &lt;li>INFO&lt;/li>
    *   &lt;li>DEBUG&lt;/li>
    *   &lt;li>TRACE - lower level A level automatically includes higher level.&lt;/li>
    *   &lt;/ul>&lt;/p>
    *   By default, categories are set to *:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO.&lt;br>
    *   Setting the categories to "" prevent any logs to be outputed.
    * @function
    * @name RPCDaemon#otherSetLogCategories
    * @param {Object} opts
    * @param {number} [opts.categories] - Daemon log categories to enable.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  "categories": "*:INFO",
    *  "status": "OK"
    * }
    */
    return new Promise((resolve, reject) => {
      opts = opts || {}
      return this.queue.add(() => {
        return this._request_other('set_log_categories', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetTransactionPool = function () {
    /**
    * Show information about valid transactions seen by the node but not yet mined into a block, as well as spent key image information for the txpool in the node's memory.
    * @function
    * @name RPCDaemon#otherGetTransactionPool
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  spent_key_images:
    *  [
    *   { id_hash: '12f6051aea57b598e7aefe436545ab55f449b11d392fffd76e33eef53ad9b962',
    *     txs_hashes: [Array] },
     *    ...
     * ],
     * status: 'OK',
     * transactions:
     * [
     *  { blob_size: 4384,
     *    do_not_relay: false,
     *    double_spend_seen: false,
     *    fee: 37750,
     *    id_hash:
     *    '3fa2745621696d4e87d997e32409469cc3d734fda186f37878b8db2972a99a41',
     *    kept_by_block: false,
     *    last_failed_height: 0,
     *    last_failed_id_hash:
     *    '0000000000000000000000000000000000000000000000000000000000000000',
     *    last_relayed_time: 1554589504,
     *    max_used_block_height: 149373,
     *    max_used_block_id_hash:
     *    '3ed0b7d1c294def73dda48c6b3f43d724525fcbc08672782ec3a1e4c5a1b2f01',
     *    receive_time: 1554589504,
     *    relayed: true,
     *    tx_blob: ... ,
     *    tx_json: ... ,
     *   }
     * ],
     * untrusted: false
     * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_transaction_pool')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherGetTransactionPoolStats = function () {
    /**
    * Get the transaction pool statistics.
    * @function
    * @name RPCDaemon#otherGetTransactionPool
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  pool_stats:
    *  {
    *   bytes_max: 2785,
    *   bytes_med: 2785,
    *   bytes_min: 2785,
    *   bytes_total: 2785,
    *   fee_total: 22650,
    *   histo_98pc: 0,
    *   num_10m: 0,
    *   num_double_spends: 0,
    *   num_failing: 0,
    *   num_not_relayed: 0,
    *   oldest: 1554589922,
    *   txs_total: 1
    *  },
    *  status: 'OK',
    *  untrusted: false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_transaction_pool_stats')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherStopDaemon = function () {
    /**
    * Send a command to the daemon to safely disconnect and shut down.
    * @function
    * @name RPCDaemon#otherStopDaemon
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { "status": "OK" }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('stop_daemon')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  /*
  // This method is a convenient backward support and should not be used anymore. See get_info JSON RPC for details.
  RPCDaemon.prototype.otherGetInfo = function () {
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_info')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }
*/

  RPCDaemon.prototype.otherGetLimit = function () {
    /**
    * Get daemon bandwidth limits.
    * @function
    * @name RPCDaemon#otherGetLimit
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  "limit_down": 8192,
    *  "limit_up": 128,
    *  "status": "OK",
    *  "untrusted": false
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('get_limit')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherSetLimit = function (opts) {
    /**
    * Set daemon bandwidth limits.
    * @function
    * @name RPCDaemon#otherSetLimit
    * @param {Object} opts
    * @param {number} [opts.limit_down] - Download limit in kBytes per second (-1 reset to default, 0 don't change the current limit).
    * @param {number} [opts.limit_up] - Upload limit in kBytes per second (-1 reset to default, 0 don't change the current limit).
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * {
    *  limit_down: 16384,
    *  limit_up: 4096,
    *  status: 'OK'
    * }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        return this._request_other('set_limit', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherOutPeers = function (opts) {
    /**
    * Limit number of outgoing peers.
    * @function
    * @name RPCDaemon#otherOutPeers
    * @param {Object} opts
    * @param {number} opts.out_peers - Max number of outgoing peers.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.out_peers === 'undefined') return reject(new Error('must specify out_peers'))
        return this._request_other('out_peers', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

  RPCDaemon.prototype.otherInPeers = function (opts) {
    /**
    * Limit number of incoming peers.
    * @function
    * @name RPCDaemon#otherOutPeers
    * @param {Object} opts
    * @param {number} opts.in_peers - Max number of incoming peers.
    * @returns {Promise} Promise object.
    * @example &lt;caption>&lt;b>Output&lt;/b>&lt;/caption>
    * { status: 'OK' }
    */

    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        opts = opts || {}
        if (typeof opts.in_peers === 'undefined') return reject(new Error('must specify in_peers'))
        return this._request_other('in_peers', opts)
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }
  /*
  // Obsolete. Conserved here for reference.
  RPCDaemon.prototype.otherStartSaveGraph = function () {
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('start_save_graph')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }

    // Obsolete. Conserved here for reference.
    RPCDaemon.prototype.otherStopSaveGraph = function () {
    return new Promise((resolve, reject) => {
      return this.queue.add(() => {
        this._request_other('stop_save_graph')
          .then((res) => {
            return resolve(res)
          }).catch((err) => {
            return reject(err)
          })
      })
    })
  }
  */

  // /get_outs to implement
  // /update to implement

  RPCDaemon.prototype._request_rpc = function (method, parameters) {
    return new Promise((resolve, reject) => {
      this.options.path = '/json_rpc'
      if (typeof parameters === 'undefined') {
        return this._request(`{"jsonrpc":"2.0","id":"0","method":"${method}"}`).then((res) => {
          let json = JSON.parse(res.body)
          if (json.result &amp;&amp; json.result['status'] === 'OK') {
            return resolve(json.result)
          } else {
            let error = new Error('RPC Error!')
            error.code = json.error['code']
            error.message = json.error['message']
            return reject(error)
          }
        }).catch((err) => {
          return reject(err)
        })
      } else {
        return this._request(`{"jsonrpc":"2.0","id":"0","method":"${method}","params":${JSON.stringify(parameters)}}`).then((res) => {
          let json = JSON.parse(res.body)
          if (json.result) {
            return resolve(json.result)
          } else {
            let error = new Error('RPC Error!')
            error.code = json.error['code']
            error.message = json.error['message']
            return reject(error)
          }
        }).catch((err) => {
          return reject(err)
        })
      }
    })
  }

  RPCDaemon.prototype._request_other = function (method, parameters) {
    return new Promise((resolve, reject) => {
      this.options.path = '/' + method
      if (typeof parameters === 'undefined') {
        return this._request().then((res) => {
          if (res.status === '200') {
            let json = JSON.parse(res.body)
            if (json.status === 'OK') {
              return resolve(json)
            } else {
              let error = new Error('RPC Error!')
              error.code = json.error['code']
              error.message = json.error['message']
              return reject(error)
            }
          } else {
            let error = new Error('HTTP Error!')
            error.code = res.status
            error.message = res.body
            return reject(error)
          }
        }).catch((err) => {
          return reject(err)
        })
      } else {
        return this._request(`${JSON.stringify(parameters)}`).then((res) => {
          if (res.status === '200') {
            let json = JSON.parse(res.body)
            if (json.status === 'OK') {
              return resolve(json)
            } else {
              let error = new Error('RPC Error!')
              error.code = json.error['code']
              error.message = json.error['message']
              return reject(error)
            }
          } else {
            let error = new Error('HTTP Error!')
            error.code = res.status
            error.message = res.body
            return reject(error)
          }
        }).catch((err) => {
          return reject(err)
        })
      }
    })
  }

  return RPCDaemon
})()

module.exports = RPCDaemon
</code></pre>
  </article>
</section>

    



  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
  </footer>

    

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>
  <script src="scripts/scrollbar.js"></script>
  <script src="scripts/collapsible.js"></script>
  <script src="scripts/jquery.selectric.min.js"></script>
  <script src="scripts/clipboard.min.js"></script>

  <script>hljs.initHighlightingOnLoad();</script>

  
  <script>
      $(function () {
          $('#menu-container').scrollbar();

          
      });
    </script>
</body>
</html>
